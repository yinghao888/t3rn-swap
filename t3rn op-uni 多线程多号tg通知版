from web3 import Web3
import time
import requests
from typing import List, Dict
import threading

# === å¯è‡ªå®šä¹‰å‚æ•° ===
ACCOUNTS = [
    {"private_key": "", "name": "Account1"},
    {"private_key": "", "name": "Account2"},
    {"private_key": "", "name": "Account3"},
    {"private_key": "", "name": "Account4"},
    {"private_key": "", "name": "Account5"},
    {"private_key": "", "name": "Account6"},
    {"private_key": "", "name": "Account7"},
    {"private_key": "", "name": "Account8"},
    {"private_key": "", "name": "Account9"},
    {"private_key": "", "name": "Account10"},
    {"private_key": "", "name": "Account11"},
    {"private_key": "", "name": "Account12"},
    {"private_key": "", "name": "Account13"},
    {"private_key": "", "name": "Account14"},
]
AMOUNT_ETH = 3.5  # æ¯æ¬¡è·¨é“¾é‡‘é¢ï¼ˆå•ä½ï¼šETHï¼‰
TIMES = 50  # æ¯ä¸ªè´¦æˆ·æ¯è½®äº’è·¨æ¥å›æ¬¡æ•°
DELAY_BETWEEN_ACCOUNTS = 0.01  # æ¯ä¸ªè´¦æˆ·ä¹‹é—´çš„å»¶è¿Ÿï¼ˆç§’ï¼‰
DELAY_BETWEEN_ROUNDS = 10 * 60  # æ¯è½®ä¹‹é—´çš„å»¶è¿Ÿï¼ˆ10åˆ†é’Ÿï¼Œä»ç¬¬ä¸€æ®µä»£ç ç§»æ¤ï¼‰

# Telegram å‚æ•°
TELEGRAM_TOKEN = "6993725114:AAHiPLxxYSt-TGiylqxscjkDC7ba2iJsilE"
TELEGRAM_CHAT_ID = "6573297379"
TELEGRAM_REPORT_INTERVAL = 600  # æ¯ 10 åˆ†é’Ÿï¼ˆ600 ç§’ï¼‰å‘é€ä¸€æ¬¡æŠ¥å‘Š

# RPC åœ°å€
UNI_RPC_URL = "https://unichain-sepolia.drpc.org"
ARB_RPC_URL = "https://sepolia-rollup.arbitrum.io/rpc"

# åˆçº¦åœ°å€
ARB_CONTRACT_ADDRESS = "0x22B65d0B9b59af4D3Ed59F18b9Ad53f5F4908B54"  # ARB -> UNI
UNI_CONTRACT_ADDRESS = "0x1cEAb5967E5f078Fa0FEC3DFfD0394Af1fEeBCC9"  # UNI -> ARB

# æ•°æ®æ¨¡æ¿
UNI_DATA_TEMPLATE = "0x56591d5961726274000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{address}0000000000000000000000000000000000000000000000003092467525c6a05c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030927f74c9de0000"
ARB_DATA_TEMPLATE = "0x56591d59756e6974000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{address}00000000000000000000000000000000000000000000000030924a11f45534fa0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030927f74c9de0000"

# ANSI é¢œè‰²ä»£ç 
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
BLUE = "\033[94m"
RESET = "\033[0m"

# å…¨å±€è®¡æ•°å™¨
success_count = 0
total_success_count = 0
minute_success_count = 0
last_minute_time = time.time()
start_time = time.time()  # ç¨‹åºå¼€å§‹æ—¶é—´

# è´¦æˆ·åˆå§‹åŒ–
accounts: List[Dict] = []
for acc in ACCOUNTS:
    account = Web3(Web3.HTTPProvider(UNI_RPC_URL)).eth.account.from_key(acc["private_key"])
    address = account.address[2:]  # å»æ‰ "0x"
    accounts.append({
        "name": acc["name"],
        "private_key": acc["private_key"],
        "address": account.address,
        "address_no_prefix": address,
        "uni_data": UNI_DATA_TEMPLATE.format(address=address),  # UNI -> ARB
        "arb_data": ARB_DATA_TEMPLATE.format(address=address)   # ARB -> UNI
    })

# å‘é€ Telegram æ¶ˆæ¯
def send_telegram_message(message: str):
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        data = {
            "chat_id": TELEGRAM_CHAT_ID,
            "text": message
        }
        response = requests.post(url, data=data)
        if response.json().get("ok"):
            print(f"ğŸ“© Telegram æ¶ˆæ¯å‘é€æˆåŠŸ: {message}")
        else:
            print(f"âŒ Telegram æ¶ˆæ¯å‘é€å¤±è´¥: {response.json()}")
    except Exception as e:
        print(f"âŒ Telegram æ¶ˆæ¯å‘é€å¤±è´¥: {e}")

# å°†ç§’æ•°è½¬æ¢ä¸ºå¯è¯»çš„æ—¶é—´æ ¼å¼
def format_time(seconds: float) -> str:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    return f"{hours}å°æ—¶ {minutes}åˆ†é’Ÿ {secs}ç§’"

# å®šæ—¶æŠ¥å‘Šå’Œåˆ†é’Ÿç»Ÿè®¡å‡½æ•°
def report_worker():
    global success_count, total_success_count, minute_success_count, last_minute_time, start_time
    while True:
        current_time = time.time()
        # æ¯åˆ†é’Ÿç»Ÿè®¡
        if current_time - last_minute_time >= 60:
            runtime = current_time - start_time
            print(f"\n{YELLOW}=================================================={RESET}")
            print(f"{GREEN}ğŸ“ŠğŸ“ŠğŸ“Š åˆ†é’Ÿäº¤æ˜“ç»Ÿè®¡ ğŸ“ŠğŸ“ŠğŸ“Š{RESET}")
            print(f"{BLUE}ä¸Šä¸€åˆ†é’Ÿå®Œæˆ: {minute_success_count} ç¬”äº¤æ˜“ ğŸš€{RESET}")
            print(f"{BLUE}ç´¯è®¡å®Œæˆæ€»æ•°: {total_success_count} ç¬”äº¤æ˜“ ğŸŒŸ{RESET}")
            print(f"{BLUE}ç´¯è®¡è¿è¡Œæ—¶é—´: {format_time(runtime)} â°{RESET}")
            print(f"{YELLOW}=================================================={RESET}\n")
            minute_success_count = 0
            last_minute_time = current_time
        # æ¯10åˆ†é’ŸæŠ¥å‘Š
        if current_time - last_minute_time >= TELEGRAM_REPORT_INTERVAL:
            runtime = current_time - start_time
            message = f"è¿‡å» 10 åˆ†é’Ÿå®Œæˆè·¨é“¾æ¬¡æ•°: {success_count} ğŸš€\næ€»è®¡å®Œæˆ: {total_success_count} ğŸ‰\nè¿è¡Œæ—¶é—´: {format_time(runtime)} â°"
            send_telegram_message(message)
            success_count = 0
        time.sleep(1)

# ä» UNI è·¨åˆ° ARB
def bridge_uni_to_arb(account_info: Dict, amount_eth: float, w3_uni: Web3) -> bool:
    global success_count, total_success_count, minute_success_count
    try:
        amount_wei = w3_uni.to_wei(amount_eth, 'ether')
        balance_uni = w3_uni.eth.get_balance(account_info["address"])
        gas_price = w3_uni.to_wei(1.6, 'gwei')
        gas_limit = 400000
        estimated_gas_cost = gas_price * gas_limit
        total_cost = amount_wei + estimated_gas_cost
        print(f"ğŸ’° {account_info['name']} UNI ä½™é¢: {w3_uni.from_wei(balance_uni, 'ether')} ETH")
        print(f"â›½ é¢„ä¼° Gas è´¹ç”¨: {w3_uni.from_wei(estimated_gas_cost, 'ether')} ETH")
        print(f"ğŸ’¸ æ€»è´¹ç”¨ (é‡‘é¢ + Gas): {w3_uni.from_wei(total_cost, 'ether')} ETH")
        if balance_uni < total_cost:
            print(f"âš ï¸ {account_info['name']} UNI ä½™é¢ä¸è¶³ï¼Œéœ€è¦ {w3_uni.from_wei(total_cost, 'ether')} ETHï¼Œå®é™…ä½™é¢ {w3_uni.from_wei(balance_uni, 'ether')} ETH ğŸ˜¢")
            return False
        nonce = w3_uni.eth.get_transaction_count(account_info["address"])
        tx = {
            'from': account_info["address"],
            'to': UNI_CONTRACT_ADDRESS,
            'value': amount_wei,
            'nonce': nonce,
            'gas': gas_limit,
            'gasPrice': gas_price,
            'chainId': 1301,
            'data': account_info["uni_data"]
        }
        print(f"ğŸš€ {account_info['name']} UNI -> ARB: å‘é€ {amount_eth} ETH")
        signed_tx = w3_uni.eth.account.sign_transaction(tx, account_info["private_key"])
        raw_tx = signed_tx.raw_transaction if hasattr(signed_tx, 'raw_transaction') else signed_tx['raw']
        tx_hash = w3_uni.eth.send_raw_transaction(raw_tx)
        print(f"ğŸ“œ {account_info['name']} UNI -> ARB äº¤æ˜“å“ˆå¸Œ: {w3_uni.to_hex(tx_hash)}")
        tx_receipt = w3_uni.eth.wait_for_transaction_receipt(tx_hash)
        print(f"âœ… {account_info['name']} äº¤æ˜“ç¡®è®¤ï¼ŒåŒºå—å·: {tx_receipt.blockNumber} ğŸ‰")
        success_count += 1
        total_success_count += 1
        minute_success_count += 1
        return True
    except Exception as e:
        print(f"âŒ {account_info['name']} UNI -> ARB å¤±è´¥: {e} ğŸ˜­")
        return False

# ä» ARB è·¨å› UNI
def bridge_arb_to_uni(account_info: Dict, amount_eth: float, w3_arb: Web3) -> bool:
    global success_count, total_success_count, minute_success_count
    try:
        amount_wei = w3_arb.to_wei(amount_eth, 'ether')
        balance_arb = w3_arb.eth.get_balance(account_info["address"])
        gas_price = w3_arb.to_wei(0.1, 'gwei')
        gas_limit = 400000
        estimated_gas_cost = gas_price * gas_limit
        total_cost = amount_wei + estimated_gas_cost
        print(f"ğŸ’° {account_info['name']} ARB ä½™é¢: {w3_arb.from_wei(balance_arb, 'ether')} ETH")
        print(f"â›½ é¢„ä¼° Gas è´¹ç”¨: {w3_arb.from_wei(estimated_gas_cost, 'ether')} ETH")
        print(f"ğŸ’¸ æ€»è´¹ç”¨ (é‡‘é¢ + Gas): {w3_arb.from_wei(total_cost, 'ether')} ETH")
        if balance_arb < total_cost:
            print(f"âš ï¸ {account_info['name']} ARB ä½™é¢ä¸è¶³ï¼Œéœ€è¦ {w3_arb.from_wei(total_cost, 'ether')} ETHï¼Œå®é™…ä½™é¢ {w3_arb.from_wei(balance_arb, 'ether')} ETH ğŸ˜¢")
            return False
        nonce = w3_arb.eth.get_transaction_count(account_info["address"])
        tx = {
            'from': account_info["address"],
            'to': ARB_CONTRACT_ADDRESS,
            'value': amount_wei,
            'nonce': nonce,
            'gas': gas_limit,
            'gasPrice': gas_price,
            'chainId': 421614,
            'data': account_info["arb_data"]
        }
        print(f"ğŸš€ {account_info['name']} ARB -> UNI: å‘é€ {amount_eth} ETH")
        signed_tx = w3_arb.eth.account.sign_transaction(tx, account_info["private_key"])
        raw_tx = signed_tx.raw_transaction if hasattr(signed_tx, 'raw_transaction') else signed_tx['raw']
        tx_hash = w3_arb.eth.send_raw_transaction(raw_tx)
        print(f"ğŸ“œ {account_info['name']} ARB -> UNI äº¤æ˜“å“ˆå¸Œ: {w3_arb.to_hex(tx_hash)}")
        tx_receipt = w3_arb.eth.wait_for_transaction_receipt(tx_hash)
        print(f"âœ… {account_info['name']} äº¤æ˜“ç¡®è®¤ï¼ŒåŒºå—å·: {tx_receipt.blockNumber} ğŸ‰")
        success_count += 1
        total_success_count += 1
        minute_success_count += 1
        return True
    except Exception as e:
        print(f"âŒ {account_info['name']} ARB -> UNI å¤±è´¥: {e} ğŸ˜­")
        return False

# ä¸»æ‰§è¡Œé€»è¾‘ï¼ˆæ— é™å¾ªç¯ï¼‰
def run_bridge():
    global start_time
    start_time = time.time()  # é‡ç½®å¼€å§‹æ—¶é—´
    print(f"ğŸŒˆ å¼€å§‹ä¸º {len(accounts)} ä¸ªè´¦æˆ·æ‰§è¡Œ UNI-ARB æ— é™å¾ªç¯è·¨é“¾ï¼Œæ¯æ¬¡ {AMOUNT_ETH} ETH ğŸ‰")
    
    # åˆ›å»º Web3 å®ä¾‹
    w3_uni = Web3(Web3.HTTPProvider(UNI_RPC_URL, request_kwargs={'timeout': 30}))
    w3_arb = Web3(Web3.HTTPProvider(ARB_RPC_URL, request_kwargs={'timeout': 30}))
    
    if not w3_uni.is_connected():
        print(f"{RED}âŒ æ— æ³•è¿æ¥åˆ° UNI æµ‹è¯•ç½‘ï¼Œç¨‹åºé€€å‡º ğŸ˜¢{RESET}")
        return
    if not w3_arb.is_connected():
        print(f"{RED}âŒ æ— æ³•è¿æ¥åˆ° ARB æµ‹è¯•ç½‘ï¼Œç¨‹åºé€€å‡º ğŸ˜¢{RESET}")
        return
    print(f"{GREEN}âœ… æˆåŠŸè¿æ¥åˆ° UNI å’Œ ARB æµ‹è¯•ç½‘ ğŸŒŸ{RESET}")

    # å¯åŠ¨æŠ¥å‘Šçº¿ç¨‹
    report_thread = threading.Thread(target=report_worker, daemon=True)
    report_thread.start()

    round_count = 0
    while True:  # æ— é™å¾ªç¯
        round_count += 1
        print(f"\n{YELLOW}âœ¨ === ç¬¬ {round_count} è½®è·¨é“¾å¼€å§‹ === âœ¨{RESET}")
        
        for i in range(TIMES):
            print(f"\n{BLUE}ğŸ‘‰ ç¬¬ {i+1}/{TIMES} æ¬¡è·¨é“¾æ“ä½œ{RESET}")
            for account_info in accounts:
                print(f"{BLUE}ğŸ‘¤ å¤„ç†è´¦æˆ·: {account_info['name']} ğŸŒŸ{RESET}")
                
                # UNI -> ARB
                uni_success = bridge_uni_to_arb(account_info, AMOUNT_ETH, w3_uni)
                if not uni_success:
                    print(f"âš ï¸ {account_info['name']} UNI -> ARB å¤±è´¥ï¼Œä½†å°†ç»§ç»­å°è¯• ARB -> UNI ğŸ˜…")
                
                # æ— è®º UNI æ˜¯å¦æˆåŠŸï¼Œéƒ½å°è¯• ARB -> UNI
                arb_success = bridge_arb_to_uni(account_info, AMOUNT_ETH, w3_arb)
                if not arb_success:
                    print(f"âš ï¸ {account_info['name']} ARB -> UNI å¤±è´¥ï¼Œç»§ç»­ä¸‹ä¸€è´¦æˆ· ğŸ˜…")
                
                # è´¦æˆ·é—´å»¶è¿Ÿ
                time.sleep(DELAY_BETWEEN_ACCOUNTS)
        
        print(f"{GREEN}ğŸ‰ ç¬¬ {round_count} è½®è·¨é“¾æ“ä½œå®Œæˆï¼Œç­‰å¾… {DELAY_BETWEEN_ROUNDS // 60} åˆ†é’Ÿåå¼€å§‹ä¸‹ä¸€è½®... â³{RESET}")
        time.sleep(DELAY_BETWEEN_ROUNDS)  # æ¯è½®ç»“æŸåç­‰å¾… 10 åˆ†é’Ÿ

if __name__ == "__main__":
    run_bridge()
