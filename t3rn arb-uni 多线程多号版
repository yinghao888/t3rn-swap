from web3 import Web3
import time
from typing import List, Dict
import threading
import random

ACCOUNTS = [
    {"private_key": "", "name": "è´¦æˆ·1"},
    {"private_key": "", "name": "è´¦æˆ·2"},
]
AMOUNT_ETH = 3.5
PAUSE_DURATION = 120
MAX_FAILURES = 3
RPC_PAUSE_DURATION = 600  # 10åˆ†é’Ÿ

UNI_RPC_URLS = [
    "https://unichain-sepolia.drpc.org",
    "https://sepolia.unichain.org",
    "https://unichain-sepolia-rpc.publicnode.com",
    "https://endpoints.omniatech.io/v1/unichain/sepolia/public",
    "https://unichain-sepolia.api.onfinality.io/public",
    "https://node.histori.xyz/unichain-sepolia/8ry9f6t9dct1se2hlagxnd9n2a",
    "https://unichain-sepolia.public.blastapi.io",
    "https://unichain-sepolia.blockpi.network/v1/rpc/public",
    "https://unichain-sepolia.rpc.hypersync.xyz/",
    "https://unichain-sepolia.gateway.tenderly.co",
    "https://1301.rpc.thirdweb.com/"
]
ARB_RPC_URLS = [
    "https://sepolia-rollup.arbitrum.io/rpc",
    "https://arbitrum-sepolia.blockpi.network/v1/rpc/private",
    "https://public.stackup.sh/api/v1/node/arbitrum-sepolia",
    "https://endpoints.omniatech.io/v1/arbitrum/sepolia/public",
    "https://arbitrum-sepolia.gateway.tenderly.co",
    "https://api.zan.top/arb-sepolia",
    "https://arbitrum-sepolia-rpc.publicnode.com"
]

ARB_CONTRACT_ADDRESS = "0x22B65d0B9b59af4D3Ed59F18b9Ad53f5F4908B54"
UNI_CONTRACT_ADDRESS = "0x1cEAb5967E5f078Fa0FEC3DFfD0394Af1fEeBCC9"

UNI_DATA_TEMPLATE = "0x56591d5961726274000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{address}0000000000000000000000000000000000000000000000003092467525c6a05c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030927f74c9de0000"
ARB_DATA_TEMPLATE = "0x56591d59756e6974000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{address}00000000000000000000000000000000000000000000000030924a11f45534fa0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030927f74c9de0000"

GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
BLUE = "\033[94m"
RESET = "\033[0m"

success_count = 0
total_success_count = 0
minute_success_count = 0
last_minute_time = time.time()
start_time = time.time()

class RPCManager:
    def __init__(self, rpc_urls: List[str]):
        self.rpc_urls = rpc_urls
        self.current_index = -1
        self.failed_attempts = {}
        self.paused_until = {}

    def get_next_rpc(self) -> str:
        self.current_index = (self.current_index + 1) % len(self.rpc_urls)
        rpc_url = self.rpc_urls[self.current_index]
        current_time = time.time()
        while (self.failed_attempts.get(rpc_url, 0) >= MAX_FAILURES or 
               current_time < self.paused_until.get(rpc_url, 0)):
            self.current_index = (self.current_index + 1) % len(self.rpc_urls)
            rpc_url = self.rpc_urls[self.current_index]
            if current_time < self.paused_until.get(rpc_url, 0):
                remaining = self.paused_until[rpc_url] - current_time
                print(f"â³ RPC {rpc_url} æš‚åœä¸­ï¼Œå‰©ä½™ {int(remaining)} ç§’ â³")
        return rpc_url

    def mark_failure(self, rpc_url: str):
        self.failed_attempts[rpc_url] = self.failed_attempts.get(rpc_url, 0) + 1
        print(f"{YELLOW}RPC {rpc_url} å¤±è´¥æ¬¡æ•°: {self.failed_attempts[rpc_url]} ğŸš¨{RESET}")
        if self.failed_attempts[rpc_url] >= MAX_FAILURES:
            self.paused_until[rpc_url] = time.time() + RPC_PAUSE_DURATION
            print(f"â¸ï¸ RPC {rpc_url} å¤±è´¥ {MAX_FAILURES} æ¬¡ï¼Œæš‚åœ {RPC_PAUSE_DURATION} ç§’ ğŸ˜")

    def create_web3_instance(self) -> Web3:
        while True:
            rpc_url = self.get_next_rpc()
            w3 = Web3(Web3.HTTPProvider(rpc_url, request_kwargs={'timeout': 30}))
            if w3.is_connected():
                return w3
            else:
                self.mark_failure(rpc_url)
                print(f"{RED}æ— æ³•è¿æ¥åˆ°RPC: {rpc_url}ï¼Œæ¢ä¸‹ä¸€ä¸ª ğŸ”„{RESET}")
                time.sleep(1)

    def test_all_rpcs(self):
        valid_rpcs = []
        for rpc_url in self.rpc_urls[:]:
            success = False
            for attempt in range(MAX_FAILURES):
                w3 = Web3(Web3.HTTPProvider(rpc_url, request_kwargs={'timeout': 30}))
                if w3.is_connected():
                    print(f"{GREEN}RPC {rpc_url} æµ‹è¯•æˆåŠŸ ğŸ‰")
                    success = True
                    break
                else:
                    print(f"{RED}RPC {rpc_url} æµ‹è¯•å¤±è´¥ (ç¬¬ {attempt + 1}/{MAX_FAILURES} æ¬¡) ğŸ˜µ")
                    time.sleep(1)
            if success:
                valid_rpcs.append(rpc_url)
            else:
                self.paused_until[rpc_url] = time.time() + RPC_PAUSE_DURATION
                print(f"â¸ï¸ RPC {rpc_url} æµ‹è¯•å…¨éƒ¨å¤±è´¥ï¼Œæš‚åœ {RPC_PAUSE_DURATION} ç§’ ğŸš«")
        self.rpc_urls = valid_rpcs
        if not self.rpc_urls:
            print(f"{RED}æ‰€æœ‰ RPC éƒ½ä¸å¯ç”¨ï¼Œç¨‹åºé€€å‡º ğŸ˜­{RESET}")
            exit(1)
        print(f"{GREEN}å¯ç”¨ RPC æ•°é‡: {len(self.rpc_urls)} ğŸŒŸ{RESET}")

accounts: List[Dict] = []
for acc in ACCOUNTS:
    temp_w3 = Web3(Web3.HTTPProvider(UNI_RPC_URLS[0]))
    account = temp_w3.eth.account.from_key(acc["private_key"])
    address = account.address[2:]
    accounts.append({
        "name": acc["name"],
        "private_key": acc["private_key"],
        "address": account.address,
        "address_no_prefix": address,
        "uni_data": UNI_DATA_TEMPLATE.format(address=address),
        "arb_data": ARB_DATA_TEMPLATE.format(address=address),
        "uni_to_arb_pause_until": 0,
        "arb_to_uni_pause_until": 0,
        "uni_to_arb_failures": 0,
        "arb_to_uni_failures": 0
    })

def format_time(seconds: float) -> str:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    return f"{hours}å°æ—¶ {minutes}åˆ†é’Ÿ {secs}ç§’"

def report_worker():
    global success_count, total_success_count, minute_success_count, last_minute_time, start_time
    while True:
        current_time = time.time()
        if current_time - last_minute_time >= 60:
            runtime = current_time - start_time
            print(f"\n{YELLOW}===== ğŸ“Š äº¤æ˜“æŠ¥å‘Š ğŸ“Š ====={RESET}")
            print(f"{GREEN}ğŸ‰ ä¸Šä¸€åˆ†é’Ÿå®Œæˆ: {minute_success_count} ç¬”äº¤æ˜“{RESET}")
            print(f"{BLUE}ğŸŒŸ ç´¯è®¡å®Œæˆ: {total_success_count} ç¬”äº¤æ˜“{RESET}")
            print(f"{BLUE}â° è¿è¡Œæ—¶é—´: {format_time(runtime)}{RESET}")
            print(f"{YELLOW}=========================={RESET}\n")
            minute_success_count = 0
            last_minute_time = current_time
        time.sleep(1)

def bridge_uni_to_arb(account_info: Dict, amount_eth: float, uni_manager: RPCManager) -> bool:
    global success_count, total_success_count, minute_success_count
    current_time = time.time()
    
    if current_time < account_info["uni_to_arb_pause_until"]:
        remaining = account_info["uni_to_arb_pause_until"] - current_time
        print(f"â° {account_info['name']} UNI â¡ï¸ ARB æš‚åœä¸­... è¿˜å‰© {int(remaining)} ç§’ ğŸ˜´")
        return False

    w3_uni = uni_manager.create_web3_instance()
    try:
        amount_wei = w3_uni.to_wei(amount_eth, 'ether')
        balance_uni = w3_uni.eth.get_balance(account_info["address"])
        gas_price = w3_uni.to_wei(1.6, 'gwei')
        gas_limit = 400000
        estimated_gas_cost = gas_price * gas_limit
        total_cost = amount_wei + estimated_gas_cost
        
        if balance_uni < total_cost:
            account_info["uni_to_arb_failures"] += 1
            print(f"ğŸ’¸ {account_info['name']} UNI â¡ï¸ ARB ä½™é¢ä¸è¶³ï¼Œå¤±è´¥æ¬¡æ•°: {account_info['uni_to_arb_failures']} âš ï¸")
            if account_info["uni_to_arb_failures"] >= MAX_FAILURES:
                account_info["uni_to_arb_pause_until"] = current_time + PAUSE_DURATION
                account_info["uni_to_arb_failures"] = 0
                print(f"â¸ï¸ {account_info['name']} UNI â¡ï¸ ARB å¤±è´¥ {MAX_FAILURES} æ¬¡ï¼Œæš‚åœ {PAUSE_DURATION} ç§’ ğŸ˜")
            return False
        
        nonce = w3_uni.eth.get_transaction_count(account_info["address"])
        tx = {
            'from': account_info["address"],
            'to': UNI_CONTRACT_ADDRESS,
            'value': amount_wei,
            'nonce': nonce,
            'gas': gas_limit,
            'gasPrice': gas_price,
            'chainId': 1301,
            'data': account_info["uni_data"]
        }
        signed_tx = w3_uni.eth.account.sign_transaction(tx, account_info["private_key"])
        raw_tx = signed_tx.raw_transaction if hasattr(signed_tx, 'raw_transaction') else signed_tx['raw']
        tx_hash = w3_uni.eth.send_raw_transaction(raw_tx)
        tx_receipt = w3_uni.eth.wait_for_transaction_receipt(tx_hash)
        print(f"ğŸ‰ {account_info['name']} UNI â¡ï¸ ARB è·¨é“¾æˆåŠŸï¼åŒºå—: {tx_receipt.blockNumber} ğŸš€")
        account_info["uni_to_arb_failures"] = 0
        success_count += 1
        total_success_count += 1
        minute_success_count += 1
        return True
    except Exception:
        account_info["uni_to_arb_failures"] += 1
        print(f"ğŸ˜µ {account_info['name']} UNI â¡ï¸ ARB è·¨é“¾å¤±è´¥ï¼Œå¤±è´¥æ¬¡æ•°: {account_info['uni_to_arb_failures']} âš ï¸")
        if account_info["uni_to_arb_failures"] >= MAX_FAILURES:
            account_info["uni_to_arb_pause_until"] = current_time + PAUSE_DURATION
            account_info["uni_to_arb_failures"] = 0
            print(f"â¸ï¸ {account_info['name']} UNI â¡ï¸ ARB å¤±è´¥ {MAX_FAILURES} æ¬¡ï¼Œæš‚åœ {PAUSE_DURATION} ç§’ ğŸ˜")
        uni_manager.mark_failure(w3_uni.provider.endpoint_uri)
        return False

def bridge_arb_to_uni(account_info: Dict, amount_eth: float, arb_manager: RPCManager) -> bool:
    global success_count, total_success_count, minute_success_count
    current_time = time.time()
    
    if current_time < account_info["arb_to_uni_pause_until"]:
        remaining = account_info["arb_to_uni_pause_until"] - current_time
        print(f"â° {account_info['name']} ARB â¡ï¸ UNI æš‚åœä¸­... è¿˜å‰© {int(remaining)} ç§’ ğŸ˜´")
        return False

    w3_arb = arb_manager.create_web3_instance()
    try:
        amount_wei = w3_arb.to_wei(amount_eth, 'ether')
        balance_arb = w3_arb.eth.get_balance(account_info["address"])
        gas_price = w3_arb.to_wei(0.1, 'gwei')
        gas_limit = 400000
        estimated_gas_cost = gas_price * gas_limit
        total_cost = amount_wei + estimated_gas_cost
        
        if balance_arb < total_cost:
            account_info["arb_to_uni_failures"] += 1
            print(f"ğŸ’¸ {account_info['name']} ARB â¡ï¸ UNI ä½™é¢ä¸è¶³ï¼Œå¤±è´¥æ¬¡æ•°: {account_info['arb_to_uni_failures']} âš ï¸")
            if account_info["arb_to_uni_failures"] >= MAX_FAILURES:
                account_info["arb_to_uni_pause_until"] = current_time + PAUSE_DURATION
                account_info["arb_to_uni_failures"] = 0
                print(f"â¸ï¸ {account_info['name']} ARB â¡ï¸ UNI å¤±è´¥ {MAX_FAILURES} æ¬¡ï¼Œæš‚åœ {PAUSE_DURATION} ç§’ ğŸ˜")
            return False
        
        nonce = w3_arb.eth.get_transaction_count(account_info["address"])
        tx = {
            'from': account_info["address"],
            'to': ARB_CONTRACT_ADDRESS,
            'value': amount_wei,
            'nonce': nonce,
            'gas': gas_limit,
            'gasPrice': gas_price,
            'chainId': 421614,
            'data': account_info["arb_data"]
        }
        signed_tx = w3 eth.account.sign_transaction(tx, account_info["private_key"])
        raw_tx = signed_tx.raw_transaction if hasattr(signed_tx, 'raw_transaction') else signed_tx['raw']
        tx_hash = w3_arb.eth.send_raw_transaction(raw_tx)
        tx_receipt = w3_arb.eth.wait_for_transaction_receipt(tx_hash)
        print(f"ğŸ‰ {account_info['name']} ARB â¡ï¸ UNI è·¨é“¾æˆåŠŸï¼åŒºå—: {tx_receipt.blockNumber} ğŸš€")
        account_info["arb_to_uni_failures"] = 0
        success_count += 1
        total_success_count += 1
        minute_success_count += 1
        return True
    except Exception:
        account_info["arb_to_uni_failures"] += 1
        print(f"ğŸ˜µ {account_info['name']} ARB â¡ï¸ UNI è·¨é“¾å¤±è´¥ï¼Œå¤±è´¥æ¬¡æ•°: {account_info['arb_to_uni_failures']} âš ï¸")
        if account_info["arb_to_uni_failures"] >= MAX_FAILURES:
            account_info["arb_to_uni_pause_until"] = current_time + PAUSE_DURATION
            account_info["arb_to_uni_failures"] = 0
            print(f"â¸ï¸ {account_info['name']} ARB â¡ï¸ UNI å¤±è´¥ {MAX_FAILURES} æ¬¡ï¼Œæš‚åœ {PAUSE_DURATION} ç§’ ğŸ˜")
        arb_manager.mark_failure(w3_arb.provider.endpoint_uri)
        return False

def run_bridge():
    global start_time
    start_time = time.time()
    print(f"ğŸŒˆ å¯åŠ¨è·¨é“¾ä»»åŠ¡ï¼{len(accounts)} ä¸ªè´¦æˆ·ï¼Œæ¯æ¬¡ {AMOUNT_ETH} ETH ğŸ‰")
    
    uni_manager = RPCManager(UNI_RPC_URLS)
    arb_manager = RPCManager(ARB_RPC_URLS)

    print(f"{YELLOW}å¼€å§‹æµ‹è¯• UNI RPCs... ğŸš€{RESET}")
    uni_manager.test_all_rpcs()
    print(f"{YELLOW}å¼€å§‹æµ‹è¯• ARB RPCs... ğŸš€{RESET}")
    arb_manager.test_all_rpcs()

    report_thread = threading.Thread(target=report_worker, daemon=True)
    report_thread.start()

    round_count = 0
    while True:
        round_count += 1
        print(f"\n{YELLOW}ğŸš€ ç¬¬ {round_count} è½®è·¨é“¾å¼€å§‹ï¼ğŸš€{RESET}")
        
        for account_info in accounts:
            print(f"{BLUE}ğŸ‘¨â€ğŸš€ å¤„ç†è´¦æˆ·: {account_info['name']} âœ¨{RESET}")
            
            uni_success = bridge_uni_to_arb(account_info, AMOUNT_ETH, uni_manager)
            if not uni_success:
                print(f"ğŸ˜“ {account_info['name']} UNI â¡ï¸ ARB æœªæˆåŠŸï¼Œç»§ç»­å°è¯• ARB â¡ï¸ UNI ğŸŒˆ")
            
            arb_success = bridge_arb_to_uni(account_info, AMOUNT_ETH, arb_manager)
            if not arb_success:
                print(f"ğŸ˜“ {account_info['name']} ARB â¡ï¸ UNI æœªæˆåŠŸï¼Œè¿›å…¥ä¸‹ä¸€è´¦æˆ· ğŸ”„")
            
            time.sleep(5)

if __name__ == "__main__":
    run_bridge()
