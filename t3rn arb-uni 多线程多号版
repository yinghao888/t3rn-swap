from web3 import Web3
import time
from typing import List, Dict
import logging
from concurrent.futures import ThreadPoolExecutor

# === ANSI 颜色代码 ===
LIGHT_BLUE = "\033[96m"  # 浅蓝色（柔和的青色）
LIGHT_RED = "\033[95m"   # 浅红色（淡粉色）
RESET = "\033[0m"        # 重置颜色

# === 配置日志 ===
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')
logger = logging.getLogger()

# === 可自定义参数 ===
ACCOUNTS = [
    {"private_key": "", "name": "账户1"},
    {"private_key": "", "name": "账户2"}
]
AMOUNT_ETH = 1  # 每次跨链金额（单位：ETH）

# RPC 地址
UNI_RPC_URL = "https://unichain-sepolia.drpc.org"
ARB_RPC_URL = "https://sepolia-rollup.arbitrum.io/rpc"

# 合约地址
UNI_TO_ARB_CONTRACT = "0x1cEAb5967E5f078Fa0FEC3DFfD0394Af1fEeBCC9"
ARB_TO_UNI_CONTRACT = "0x22B65d0B9b59af4D3Ed59F18b9Ad53f5F4908B54"

# 数据模板
UNI_TO_ARB_DATA_TEMPLATE = "0x56591d5961726274000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{address}0000000000000000000000000000000000000000000000000de08e51f0c04e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000de0b6b3a7640000"
ARB_TO_UNI_DATA_TEMPLATE = "0x56591d59756e6974000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{address}0000000000000000000000000000000000000000000000000de06a4dded38400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000de0b6b3a7640000"

# 初始化 Web3 实例
w3_uni = Web3(Web3.HTTPProvider(UNI_RPC_URL, request_kwargs={'timeout': 10}))
w3_arb = Web3(Web3.HTTPProvider(ARB_RPC_URL, request_kwargs={'timeout': 10}))

# 优化参数
GAS_LIMIT_UNI = 200000
GAS_LIMIT_ARB = 200000
MIN_GAS_PRICE = w3_uni.to_wei(0.05, 'gwei')  # 最低 Gas Price

# 全局计数器
success_count = 0
total_success_count = 0
start_time = time.time()

# 账户初始化
accounts: List[Dict] = []
for acc in ACCOUNTS:
    account = w3_uni.eth.account.from_key(acc["private_key"])
    address = account.address[2:]
    accounts.append({
        "name": acc["name"],
        "private_key": acc["private_key"],
        "address": account.address,
        "address_no_prefix": address,
        "uni_data": UNI_TO_ARB_DATA_TEMPLATE.format(address=address),
        "arb_data": ARB_TO_UNI_DATA_TEMPLATE.format(address=address)
    })

# 检查连接
if not w3_uni.is_connected() or not w3_arb.is_connected():
    logger.error("无法连接到 UNI 或 ARB 测试网，程序退出")
    exit(1)
logger.info("成功连接到 UNI 和 ARB 测试网")

# 获取动态 Gas Price
def get_dynamic_gas_price(w3_instance) -> int:
    try:
        latest_block = w3_instance.eth.get_block('latest')
        base_fee = latest_block['baseFeePerGas']
        # 设置 Gas Price 为 baseFee 的 1.2 倍，确保高于最低要求
        return max(int(base_fee * 1.2), MIN_GAS_PRICE)
    except Exception as e:
        logger.warning(f"获取 Gas Price 失败，使用默认值: {e}")
        return MIN_GAS_PRICE

# UNI -> ARB 跨链函数
def bridge_uni_to_arb(account_info: Dict) -> bool:
    global success_count, total_success_count
    try:
        amount_wei = w3_uni.to_wei(AMOUNT_ETH, 'ether')
        balance = w3_uni.eth.get_balance(account_info["address"])
        gas_price = get_dynamic_gas_price(w3_uni)
        total_cost = amount_wei + (gas_price * GAS_LIMIT_UNI)
        
        if balance < total_cost:
            logger.warning(f"{account_info['name']} UNI 余额不足")
            return False

        nonce = w3_uni.eth.get_transaction_count(account_info["address"])
        tx = {
            'from': account_info["address"],
            'to': UNI_TO_ARB_CONTRACT,
            'value': amount_wei,
            'nonce': nonce,
            'gas': GAS_LIMIT_UNI,
            'gasPrice': gas_price,
            'chainId': 1301,
            'data': account_info["uni_data"]
        }
        
        signed_tx = w3_uni.eth.account.sign_transaction(tx, account_info["private_key"])
        tx_hash = w3_uni.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3_uni.eth.wait_for_transaction_receipt(tx_hash, timeout=30)
        
        success_count += 1
        total_success_count += 1
        logger.info(f"{LIGHT_BLUE}{account_info['name']} UNI -> ARB 成功{RESET}")
        return True
    except Exception as e:
        logger.error(f"{account_info['name']} UNI -> ARB 失败: {e}")
        return False

# ARB -> UNI 跨链函数
def bridge_arb_to_uni(account_info: Dict) -> bool:
    global success_count, total_success_count
    try:
        amount_wei = w3_arb.to_wei(AMOUNT_ETH, 'ether')
        balance = w3_arb.eth.get_balance(account_info["address"])
        gas_price = get_dynamic_gas_price(w3_arb)
        total_cost = amount_wei + (gas_price * GAS_LIMIT_ARB)
        
        if balance < total_cost:
            logger.warning(f"{account_info['name']} ARB 余额不足")
            return False

        nonce = w3_arb.eth.get_transaction_count(account_info["address"])
        tx = {
            'from': account_info["address"],
            'to': ARB_TO_UNI_CONTRACT,
            'value': amount_wei,
            'nonce': nonce,
            'gas': GAS_LIMIT_ARB,
            'gasPrice': gas_price,
            'chainId': 421614,
            'data': account_info["arb_data"]
        }
        
        signed_tx = w3_arb.eth.account.sign_transaction(tx, account_info["private_key"])
        tx_hash = w3_arb.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3_arb.eth.wait_for_transaction_receipt(tx_hash, timeout=30)
        
        success_count += 1
        total_success_count += 1
        logger.info(f"{LIGHT_RED}{account_info['name']} ARB -> UNI 成功{RESET}")
        return True
    except Exception as e:
        logger.error(f"{account_info['name']} ARB -> UNI 失败: {e}")
        return False

# 并行执行跨链
def process_account(account_info: Dict):
    while True:
        bridge_uni_to_arb(account_info)
        bridge_arb_to_uni(account_info)

# 主函数
def main():
    logger.info(f"开始为 {len(accounts)} 个账户执行 UNI-ARB 无限循环跨链，每次 {AMOUNT_ETH} ETH")
    
    with ThreadPoolExecutor(max_workers=min(len(accounts), 10)) as executor:
        executor.map(process_account, accounts)

if __name__ == "__main__":
    main()
